#!/usr/bin/env python3
"""
A state-driven decision node for managing an aquarium cleaning task.
It can be triggered by a service and uses feedback from the bot to execute a path
generated by a selected cleaning algorithm.
"""

import rospy
from std_srvs.srv import Trigger, TriggerResponse
from swarm_manage.msg import BotCommand, BotStatus

class CleaningAlgorithm:
    """Base class for cleaning patterns."""
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols

    def generate_path(self):
        """Returns a list of zone_ids representing the path."""
        raise NotImplementedError

class ZigZag(CleaningAlgorithm):
    """Generates a zig-zag (or raster scan) path."""
    def generate_path(self):
        path = []
        for r in range(self.rows):
            row = list(range(r * self.cols, (r + 1) * self.cols))
            if r % 2 == 1:  # On odd rows, reverse the direction
                row.reverse()
            path.extend(row)
        return path

class SpiralOut(CleaningAlgorithm):
    """Generates a path that spirals outwards from the center."""
    def generate_path(self):
        path = []
        matrix = [[-1 for _ in range(self.cols)] for _ in range(self.rows)]
        top, bottom, left, right = 0, self.rows - 1, 0, self.cols - 1
        direction = 0  # 0: right, 1: down, 2: left, 3: up
        num = 0

        while top <= bottom and left <= right:
            if direction == 0:
                for i in range(left, right + 1):
                    matrix[top][i] = num
                    num += 1
                top += 1
            elif direction == 1:
                for i in range(top, bottom + 1):
                    matrix[i][right] = num
                    num += 1
                right -= 1
            elif direction == 2:
                for i in range(right, left - 1, -1):
                    matrix[bottom][i] = num
                    num += 1
                bottom -= 1
            elif direction == 3:
                for i in range(bottom, top - 1, -1):
                    matrix[i][left] = num
                    num += 1
                left += 1
            direction = (direction + 1) % 4
        
        # Flatten and sort by the assigned number to get the spiral path
        flat_list = []
        for r in range(self.rows):
            for c in range(self.cols):
                flat_list.append(((r * self.cols + c), matrix[r][c]))
        
        flat_list.sort(key=lambda x: x[1])
        path = [item[0] for item in flat_list]
        return path


class ESPDecisionNode:
    def __init__(self):
        rospy.init_node('esp_decision_node')

        # --- Parameters ---
        self.bot_id = rospy.get_param('~bot_id', 1)
        self.grid_rows = rospy.get_param('~grid_rows', 5)
        self.grid_cols = rospy.get_param('~grid_cols', 5)
        self.cleaning_pattern_name = rospy.get_param('~cleaning_pattern', 'zigzag').lower()

        # --- State Machine ---
        self.state = 'IDLE'  # States: IDLE, MAPPING, CLEANING, FINISHED
        self.current_path = []
        self.current_waypoint_index = -1
        self.last_known_bot_status = None

        # --- Algorithm Registration ---
        self.available_patterns = {
            'zigzag': ZigZag(self.grid_rows, self.grid_cols),
            'spiral': SpiralOut(self.grid_rows, self.grid_cols)
        }
        if self.cleaning_pattern_name not in self.available_patterns:
            rospy.logwarn(f"Pattern '{self.cleaning_pattern_name}' not found. Defaulting to 'zigzag'.")
            self.cleaning_pattern_name = 'zigzag'

        # --- ROS Communication ---
        self.cmd_pub = rospy.Publisher('/bot/cmd', BotCommand, queue_size=10)
        rospy.Subscriber('/bot/status', BotStatus, self.status_cb)
        rospy.Service('/start_cleaning', Trigger, self.handle_start_cleaning)

        rospy.loginfo(f"Decision Node is in IDLE state. Ready to receive cleaning trigger.")
        rospy.loginfo(f"Using '{self.cleaning_pattern_name}' cleaning pattern.")

    def handle_start_cleaning(self, req):
        if self.state not in ['IDLE', 'FINISHED']:
            return TriggerResponse(success=False, message=f"Cannot start cleaning, node is in '{self.state}' state.")

        rospy.loginfo("Received trigger. Starting cleaning task.")
        self.state = 'PLANNING'
        
        # 1. Select and run the chosen algorithm
        planner = self.available_patterns[self.cleaning_pattern_name]
        self.current_path = planner.generate_path()
        self.current_waypoint_index = 0
        rospy.loginfo(f"Path computed with {len(self.current_path)} waypoints.")

        # 2. Start executing the first step of the path
        self.state = 'CLEANING'
        self.execute_next_waypoint()
        
        return TriggerResponse(success=True, message="Cleaning task started.")

    def status_cb(self, msg: BotStatus):
        self.last_known_bot_status = msg
        rospy.loginfo(f"Decision: received status from bot {msg.bot_id}: status='{msg.status}', cleaning={msg.cleaning}")

        # This is the feedback loop!
        # If we are in the CLEANING state and the bot reports it's no longer cleaning,
        # it means it has finished the current waypoint.
        if self.state == 'CLEANING' and not msg.cleaning:
            rospy.loginfo("Bot finished waypoint. Moving to next.")
            self.current_waypoint_index += 1
            self.execute_next_waypoint()

    def execute_next_waypoint(self):
        if self.current_waypoint_index >= len(self.current_path):
            rospy.loginfo("Completed all waypoints. Cleaning task finished.")
            self.state = 'FINISHED'
            # Optionally send a "go home" or "dock" command here
            return

        zone_id = self.current_path[self.current_waypoint_index]
        rospy.loginfo(f"Sending bot to waypoint {self.current_waypoint_index + 1}/{len(self.current_path)} (Zone ID: {zone_id})")
        
        cmd = BotCommand()
        cmd.zone_id = zone_id
        cmd.action = 'clean_zone'
        cmd.speed = 0.5
        self.cmd_pub.publish(cmd)

    def spin(self):
        rospy.spin()


if __name__ == '__main__':
    try:
        node = ESPDecisionNode()
        node.spin()
    except rospy.ROSInterruptException:
        pass
